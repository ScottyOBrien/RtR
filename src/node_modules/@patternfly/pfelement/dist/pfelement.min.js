Array.prototype.find||Object.defineProperty(Array.prototype,"find",{value:function(t){if(null==this)throw new TypeError("this is null or not defined");var e=Object(this),r=e.length>>>0;if("function"!=typeof t)throw new TypeError("predicate must be a function");for(var s=arguments[1],i=0;i<r;){var n=e[i];if(t.call(s,n,i,e))return n;i++}}}),String.prototype.includes||(String.prototype.includes=function(t,e){return"number"!=typeof e&&(e=0),!(e+t.length>this.length)&&-1!==this.indexOf(t,e)});let t=()=>null;function e(){t("[reveal] web components ready"),t("[reveal] elements ready, revealing the body"),window.document.body.removeAttribute("unresolved")}const r={object:{prop:{setter:function(t,e,r){const s=this[t];this[t]=e,r&&r(this,s,e)},getter:function(t){return this[t]},define:function(t,e,s){e||(e="_"+t),this[e]={},Object.defineProperty(this,t,{set:t=>{r.object.prop.setter.bind(this)(e,t,s)},get:()=>r.object.prop.getter.bind(this)(e),enumerable:!0})}},attr:{parse:function(t){return JSON.parse(t)},onChange:function(t,e,s,i){this[t]=r.object.attr.parse.bind(this)(i)}}},alias:{prop:{setter:function(t,e){this[t]=e},getter:function(t){return this[t]},define:function(t,e){Object.defineProperty(this,t,{set:t=>r.alias.prop.setter.bind(this)(e,t),get:()=>r.alias.prop.getter.bind(this)(e),enumerable:!0})}}},boolean:{prop:{setter:function(t,e){e?this.setAttribute(t,""):this.removeAttribute(t)},getter:function(t){return this.hasAttribute(t)&&"false"!==this.getAttribute(t)},define:function(t,e){Object.defineProperty(this,t,{set:t=>r.boolean.prop.setter.bind(this)(e,t),get:()=>r.boolean.prop.getter.bind(this)(e),enumerable:!0})}},attr:{onChange:function(t,e,s){s&&r.boolean.attr.hasChanged(t,e)&&s(this,t,e)},hasChanged:(t,e)=>{return(null==t||"false"===t)!==(null==e||"false"===e)}}},string:{prop:{setter:function(t,e){null!=e?this.setAttribute(t,e):this.removeAttribute(t)},getter:function(t){return this.hasAttribute(t)?this.getAttribute(t):null},define:function(t,e){Object.defineProperty(this,t,{set:t=>r.string.prop.setter.bind(this)(e,t),get:()=>r.string.prop.getter.bind(this)(e),enumerable:!0})}}},function:{prop:{setter:function(t,e,r){const s=this[t];this[t]=e,r&&r(this,s,e)},getter:function(t){return this[t]},define:function(t,e,s){e||(e="_"+t),this[e]={},Object.defineProperty(this,t,{set:t=>{r.function.prop.setter.bind(this)(e,t,s)},get:()=>r.function.prop.getter.bind(this)(e),enumerable:!0})}},attr:{parse:t=>(function(t){try{return"string"==typeof fn?new Function(`return ${fn}`)():"function"==typeof fn?fn:new Function}catch(t){return null}})(),onChange:function(t,e,s,i){this[t]=r.function.attr.parse.bind(this)(i)}}},number:{prop:{setter:function(t,e){null==e||isNaN(e)?this.removeAttribute(t):this.setAttribute(t,e)}}}};class s{constructor(t,e,r,s){if(this.type=t,this.attrName=e,this.propName=r,this.onChangeCallback=s,!e&&!r)throw new Error("attribute name and property name are not defined. You need to define at least one")}get attrIsObserved(){return this.attrName&&this.onChangeCallback}instanceConstructorLogic(t){this.propName&&this.defineProp(t)}getDefineFn(t){return r[this.type].prop.define.bind(t)}defineProp(t){this.getDefineFn(t)(this.propName)}onAttributeChangedLogic(t,e,r){this.onChangeCallback(t,e,r)}}class i extends s{constructor(t,e,r,s){super("object",t,e,r),this.propName&&(this.privatePropName=s||"_"+this.propName)}defineProp(t){this.getDefineFn(t)(this.propName,this.privatePropName,this.onChangeCallback)}get attrIsObserved(){return!!this.attrName}onAttributeChangedLogic(t,e,s){this.propName&&r.object.onChange.bind(t)(this.propName,this.attrName,e,s)}}class n extends s{constructor(t,e,r,s){super("string",t,e,r),this.attrName||(this.privatePropName=s||"_"+this.propName)}defineProp(t){this.attrName?this.getDefineFn(t)(this.propName,this.attrName):Object.defineProperty(t,this.propName,{set:e=>{const r=t[this.privatePropName];t[this.privatePropName]=e,this.onChangeCallback&&this.onChangeCallback(t,r,e)},get:()=>t[this.privatePropName],enumerable:!0})}}class a extends s{constructor(t,e,r,s){if(super("alias",t,e,void 0),this.aliasedPropName=r,this.aliasedAttrName=s,!s&&!s)throw new Error("Aliased property has no aliasedPropName and aliasedAttrName")}defineProp(t){this.aliasedPropName?this.getDefineFn(t)(this.propName,this.aliasedPropName):this.aliasedAttrName&&Object.defineProperty(t,this.propName,{set:e=>{t.setAttribute(this.aliasedAttrName,e)},get:()=>t.hasAttribute(this.aliasedAttrName)&&t.getAttribute(this.aliasedAttrName),enumerable:!0})}get attrIsObserved(){return!!this.attrName}onAttributeChangedLogic(t,e,r){this.aliasedAttrName?t.setAttribute(this.aliasedAttrName,r):this.aliasedPropName&&(t[this.aliasedPropName]=r)}}class o extends s{constructor(t,e,r,s){super("boolean",t,e,r),t||(this.privatePropName=s||"_"+e)}defineProp(t){this.attrName?this.getDefineFn(t)(this.propName,this.attrName):Object.defineProperty(t,this.propName,{set:e=>{const r=t[this.privatePropName];t[this.privatePropName]=!!e,this.onChangeCallback&&this.onChangeCallback(t,r,e)},get:()=>t[this.privatePropName],enumerable:!0})}}class h extends s{constructor(t,e,r,s){if(super("function",t,e,r),!e||"string"!=typeof e)throw new Error("propName must be a non-empty string for functions");this.privatePropName=s||"_"+e}defineProp(t){this.getDefineFn(t)(this.propName,this.privatePropName,this.onChangeCallback)}get attrIsObserved(){return!!this.attrName}onAttributeChangedLogic(t,e,s){r.object.onChange.bind(t)(this.propName,this.attrName,e,s)}}class p extends s{constructor(t,e,r,s,i){super(t,e,r,s),e&&!i||(this.privatePropName=i||"_"+r)}parse(t){return Number(t)}defineProp(t){if(this.privatePropName&&this.attrName)throw new Error("Not implemented yet for "+this.type+" prop and attribute");this.attrName?Object.defineProperty(t,this.propName,{set:e=>{r.number.prop.setter.bind(t)(this.attrName,e)},get:()=>{if(t.hasAttribute(this.attrName))return this.parse(t.getAttribute(this.attrName))},enumerable:!0}):Object.defineProperty(t,this.propName,{set:e=>{t[this.privatePropName];t[this.privatePropName]=e},get:()=>t[this.privatePropName],enumerable:!0})}get attrIsObserved(){return super.attrIsObserved||this.privatePropName&&this.attrName}onAttributeChangedLogic(t,e,r){if(this.privatePropName&&this.attrName)throw new Error("Not implemented yet for "+this.type+" prop and attribute");{const s=this.parse(e),i=this.parse(r);this.onChangeCallback(t,s,i)}}}class l extends p{constructor(t,e,r){super("integer",t,e,r)}parse(t){return parseInt(t)}}class d extends p{constructor(t,e,r){super("float",t,e,r)}parse(t){return parseFloat(t)}}const u=new Error("The wrapped element is not yet obtainable. The property must be set in a different way, or after the wrapped element is obtainable");class c extends s{constructor(t,e,r,s,i,n){if(super("wrapped",t,e,r),"function"!=typeof s)throw new Error("getWrappedElementFn must be a function that returns an html element for wrapped prop and attr type");if(!i&&!n)throw new Error("one of wrappedAttrName and wrappedPropName must be defined, for wrapped prop and attr type");this.getWrappedElementFn=s,this.wrappedAttrName=i,this.wrappedPropName=n}updateAttrFromWrappedAttribute(t){const e=this.getWrappedElementFn(t);if(!e)throw u;e.hasAttribute(this.wrappedAttrName)?t.setAttribute(this.attrName,e.getAttribute(this.wrappedAttrName)):t.removeAttribute(this.attrName)}updateWrappedAttribute(t,e){const r=this.getWrappedElementFn(t);if(!r)throw u;null!=e?r.setAttribute(this.wrappedAttrName,e):r.removeAttribute(this.wrappedAttrName)}defineProp(t){const e={enumerable:!0};this.wrappedPropName?(e.set=(e=>{const r=this.getWrappedElementFn(t);if(!r)throw u;{const s=t[this.propName];r[this.wrappedPropName]=e,this.wrappedAttrName&&this.attrName?this.updateAttrFromWrappedAttribute(t):this.onChangeCallback&&this.onChangeCallback(t,s,t[this.propName])}}),e.get=(()=>{const e=this.getWrappedElementFn(t);if(e)return e[this.wrappedPropName];throw u})):(e.set=(e=>{if(!this.getWrappedElementFn(t))throw u;{const r=t[this.propName];this.updateWrappedAttribute(t,e),this.attrName?this.updateAttrFromWrappedAttribute(t):this.onChangeCallback&&this.onChangeCallback(t,r,t[this.propName])}}),e.get=(()=>{const e=this.getWrappedElementFn(t);if(!e)throw u;if(e.hasAttribute(this.wrappedAttrName))return e.getAttribute(this.wrappedAttrName)})),Object.defineProperty(t,this.propName,e)}get attrIsObserved(){return!!this.attrName}onAttributeChangedLogic(t,e,r){if(!this.getWrappedElementFn(t))throw u;e!==r&&(this.wrappedAttrName?(this.updateWrappedAttribute(t,r),this.updateAttrFromWrappedAttribute(t)):this.propName&&(t[this.propName]=r),this.onChangeCallback&&this.onChangeCallback(t,e,r))}}
/*!
 * PatternFly Elements: PFElement 2.1.0-alpha.1
 * @license
 * Copyright 2020 Red Hat, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
*/const m="pfe-";class b extends HTMLElement{static create(t){window.customElements.define(t.tag,t)}static get propsAndAttrs(){return[]}static get propsAndAttrsAPI(){return{alias:a,boolean:o,float:d,function:h,integer:l,number:p,object:i,string:n,wrapped:c}}propsAndAttrsConstructorLogic(){this._pfeClass.propsAndAttrs.forEach(t=>t.instanceConstructorLogic(this))}propsAndAttrsOnAttributeChangedLogic(t,e,r){const s=this._pfeClass.propsAndAttrs.filter(e=>e.attrName===t);if(s.length){if(s.length>1)throw new Error("more than one attribute with the same name has been defined in propAndAttr api");s[0].onAttributeChangedLogic(this,e,r)}}static get propAndAttrsObservedAttributes(){return this.propsAndAttrs.filter(t=>t.attrIsObserved).map(t=>t.attrName)}static debugLog(t=null){return null!==t&&(b._debugLog=!!t),b._debugLog}static log(...t){b.debugLog()&&console.log(...t)}static get PfeTypes(){return{Container:"container",Content:"content",Combo:"combo"}}static get version(){return"{{version}}"}static get observedAttributes(){return["pfe-theme",...this.propAndAttrsObservedAttributes]}get randomId(){return Math.random().toString(36).substr(2,9)}get version(){return this._pfeClass.version}get pfeType(){return this.getAttribute(`${m}type`)}set pfeType(t){this.setAttribute(`${m}type`,t)}cssVariable(t,e,r=this){return t="--"!==t.substr(0,2)?"--"+t:t,e&&r.style.setProperty(t,e),window.getComputedStyle(r).getPropertyValue(t).trim()}has_slot(t){return this.querySelector(`[slot='${t}']`)}has_slots(t){return[...this.querySelectorAll(`[slot='${t}']`)]}context_update(){const t=this.querySelectorAll("[pfelement]");let e=this.cssVariable("theme");this.hasAttribute("pfe-theme")&&(e=this.getAttribute("pfe-theme"),this.cssVariable("theme",e)),this.context_set(e),[...t].map(t=>{t.connected&&t.context_set(e)})}context_set(t){let e=this.cssVariable("theme");e||(e=this.getAttribute("pfe-theme")),!e&&t&&(e=t),e&&this.setAttribute("on",e)}constructor(t,{type:e=null,delayRender:r=!1,customRendering:s=!1}={}){super(),this.connected=!1,this._pfeClass=t,this.tag=t.tag,this.props=t.properties,this.slots=t.slots,this._queue=[],e&&this._queueAction({type:"setProperty",data:{name:"pfeType",value:e}}),this._connectedCallback=this._connectedCallback.bind(this),this._observer=new MutationObserver(this._connectedCallback),s||(this.template=document.createElement("template"),this.log("Constructing..."),"pfe-table"!==this.tag&&this.attachShadow({mode:"open"}),r||"pfe-navigation"===this.tag&&"pfe-navigation-main"===this.tag&&"pfe-navigation-item"===this.tag&&"pfe-card"===this.tag?"pfe-table"!==this.tag&&(this.shadowRoot.innerHTML="<slot></slot>"):r||(this.log("Render..."),this.render(),this.log("Rendered."))),this.propsAndAttrsConstructorLogic()}connectedCallback(){if("pfe-navigation"===this.tag||"pfe-navigation-main"===this.tag||"pfe-navigation-item"===this.tag||"pfe-card"===this.tag)return new Promise(t=>{setTimeout(()=>{if(this.children.length)return this.render(),this._connectedCallback(),t();this._observer.observe(this,{childList:!0})},0)});this._connectedCallback()}_connectedCallback(){this.connected=!0,this.log("Connecting..."),"pfe-table"!==this.tag&&window.ShadyCSS&&(this.log("Styling..."),window.ShadyCSS.styleElement(this),this.log("Styled.")),!this.hasAttribute("pfelement")&&this.hasAttribute("on")&&console.warn(`${this.tag}${this.id?`[#${this.id}]`:""}: The "on" attribute is protected and should not be manually added to a component. The base class will manage this value for you on upgrade.`),this.classList.add("PFElement"),this.setAttribute("pfelement",""),"object"==typeof this.props&&(this._mapSchemaToProperties(this.tag,this.props),this.log("Properties attached.")),"object"==typeof this.slots&&(this._mapSchemaToSlots(this.tag,this.slots),this.log("Slots attached.")),this._queue.length&&this._processQueue(),this.context_update(),this.log("Connected.")}temporaryFixIE11EdgeSlotted(){const t=`${this.tag}`,e=document.head.querySelector(`[scope^=${t}]`);if(e){let r=Array.from(document.styleSheets).find(e=>e.ownerNode&&-1!==e.ownerNode.getAttribute("scope").indexOf(t)?e:null);if(r){let t="";Array.from(r.cssRules||r.rules||[]).forEach(e=>{e.selectorText&&"string"==typeof e.cssText&&e.selectorText.indexOf("slot")>-1?t+=" "+e.cssText.replace(/>/gi,""):e&&"string"==typeof e.cssText&&(t+=" "+e.cssText)}),t&&(e.innerText=t)}}}disconnectedCallback(){this._observer.disconnect(),this.log("Disconnecting..."),this.connected=!1,this.log("Disconnected.")}attributeChangedCallback(t,e,r){if(this._pfeClass.cascadingAttributes){const e=this._pfeClass.cascadingAttributes[t];e&&this._copyAttribute(t,e),"pfe-theme"===t&&this.context_update()}this.propsAndAttrsOnAttributeChangedLogic(t,e,r)}_copyAttribute(t,e){const r=[...this.querySelectorAll(e),...this.shadowRoot.querySelectorAll(e)],s=this.getAttribute(t),i=null==s?"removeAttribute":"setAttribute";for(const e of r)e[i](t,s)}_mapSchemaToProperties(t,e){this.log("Mapping properties..."),Object.keys(e).forEach(r=>{let s=e[r];if("object"==typeof s){let e=!0,i=r;if(this[r]=s,this[r].value=null,void 0!==this[r].prefixed&&(e=this[r].prefixed),e&&(i=`${m}${r}`),this.hasAttribute(i))this[r].value=this.getAttribute(i);else if(s.default){const e=this._hasDependency(t,s.options),n=!s.options||s.options&&!s.options.dependencies.length;(e||n)&&(this.setAttribute(i,s.default),this[r].value=s.default)}}}),this.log("Properties mapped.")}_hasDependency(t,e){let r=e?e.dependencies:[],s=!1;for(let e=0;e<r.length;e+=1){const i="slot"===r[e].type&&this.has_slots(`${t}--${r[e].id}`).length>0,n="attribute"===r[e].type&&this.getAttribute(`${m}${r[e].id}`);if(i||n){s=!0;break}}return s}_mapSchemaToSlots(t,e){this.log("Validate slots..."),Object.keys(e).forEach(r=>{let s=e[r];if("object"==typeof s){let e=!1,i=[];s.namedSlot?((i=this.has_slots(`${t}--${r}`)).length>0&&(s.nodes=i,e=!0),(i=this.has_slots(`${r}`)).length>0&&(s.nodes=i,e=!0)):(i=[...this.children].filter(t=>!t.hasAttribute("slot"))).length>0&&(s.nodes=i,e=!0),e?this.setAttribute(`has_${r}`,""):this.removeAttribute(`has_${r}`)}}),this.log("Slots validated.")}_queueAction(t){this._queue.push(t)}_processQueue(){this._queue.forEach(t=>{this[`_${t.type}`](t.data)}),this._queue=[]}_setProperty({name:t,value:e}){this[t]=e}static var(t,e=document.body){return window.getComputedStyle(e).getPropertyValue(t).trim()}var(t){return b.var(t,this)}render(){this.shadowRoot.innerHTML="",this.template.innerHTML=this.html,window.ShadyCSS&&window.ShadyCSS.prepareTemplate(this.template,this.tag),this.shadowRoot.appendChild(this.template.content.cloneNode(!0))}log(...t){b.log(`[${this.tag}]`,...t)}emitEvent(t,{bubbles:e=!0,cancelable:r=!1,composed:s=!1,detail:i={}}={}){this.log(`Custom event: ${t}`),this.dispatchEvent(new CustomEvent(t,{bubbles:e,cancelable:r,composed:s,detail:i}))}getUniqueId(t="id"){let e=t;for(let r=1;document.getElementById(e);r++)e=t+"-"+r;return e}}!function(r){t=r;const s=window.WebComponents,i=s&&window.WebComponents.ready;!s||i?e():window.addEventListener("WebComponentsReady",e)}(b.log);export default b;
//# sourceMappingURL=pfelement.min.js.map

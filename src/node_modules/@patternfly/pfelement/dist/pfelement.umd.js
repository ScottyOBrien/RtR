(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.PFElement = factory());
}(this, (function () { 'use strict';

    if (!Array.prototype.find) {
        Object.defineProperty(Array.prototype, 'find', {
            value: function value(predicate) {

                if (this == null) {
                    throw new TypeError('this is null or not defined');
                }

                var obj = Object(this);
                var len = obj.length >>> 0;

                if (typeof predicate !== 'function') {
                    throw new TypeError('predicate must be a function');
                }

                var thisArg = arguments[1];

                var index = 0;

                while (index < len) {
                    var iValue = obj[index];
                    if (predicate.call(thisArg, iValue, index, obj)) {
                        return iValue;
                    }
                    index++;
                }

                return undefined;
            }
        });
    }

    if (!String.prototype.includes) {
        String.prototype.includes = function (search, start) {

            if (typeof start !== 'number') {
                start = 0;
            }

            if (start + search.length > this.length) {
                return false;
            } else {
                return this.indexOf(search, start) !== -1;
            }
        };
    }

    var logger = function logger() {
      return null;
    };

    function reveal() {
      logger("[reveal] elements ready, revealing the body");
      window.document.body.removeAttribute("unresolved");
    }

    function autoReveal(logFunction) {
      logger = logFunction;
      // If Web Components are already ready, run the handler right away.  If they
      // are not yet ready, wait.
      //
      // see https://github.com/github/webcomponentsjs#webcomponents-loaderjs for
      // info about web component readiness events
      var polyfillPresent = window.WebComponents;
      var polyfillReady = polyfillPresent && window.WebComponents.ready;

      if (!polyfillPresent || polyfillReady) {
        handleWebComponentsReady();
      } else {
        window.addEventListener("WebComponentsReady", handleWebComponentsReady);
      }
    }

    function handleWebComponentsReady() {
      logger("[reveal] web components ready");
      reveal();
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);

      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);

        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;

        if (getter === undefined) {
          return undefined;
        }

        return getter.call(receiver);
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    function parseFunction(value) {
      try {
        if (typeof fn === "string") {
          return new Function("return " + fn)();
        } else if (typeof fn === "function") {
          return fn;
        } else {
          return new Function();
        }
      } catch (e) {
        return null;
      }
    }

    var propsAndAttrsAPI = {
      object: {
        prop: {
          setter: function setter(privatePropName, value, onChange) {
            var oldValue = this[privatePropName];
            this[privatePropName] = value;
            if (onChange) onChange(this, oldValue, value);
          },
          getter: function getter(privatePropName) {
            return this[privatePropName];
          },
          define: function define(propName, privatePropName, onChange) {
            var _this = this;

            if (!privatePropName) {
              privatePropName = "_" + propName;
            }
            this[privatePropName] = {};
            Object.defineProperty(this, propName, {
              set: function set$$1(v) {
                propsAndAttrsAPI.object.prop.setter.bind(_this)(privatePropName, v, onChange);
              },
              get: function get$$1() {
                return propsAndAttrsAPI.object.prop.getter.bind(_this)(privatePropName);
              },
              enumerable: true
            });
          }
        },
        attr: {
          parse: function parse(stringValue) {
            return JSON.parse(stringValue);
          },
          onChange: function onChange(propName, attrName, oldValue, newValue) {
            this[propName] = propsAndAttrsAPI.object.attr.parse.bind(this)(newValue);
          }
        }
      },
      alias: {
        prop: {
          setter: function setter(aliasedPropName, value) {
            this[aliasedPropName] = value;
          },
          getter: function getter(aliasedPropName) {
            return this[aliasedPropName];
          },
          define: function define(propName, aliasedPropName) {
            var _this2 = this;

            Object.defineProperty(this, propName, {
              set: function set$$1(v) {
                return propsAndAttrsAPI.alias.prop.setter.bind(_this2)(aliasedPropName, v);
              },
              get: function get$$1() {
                return propsAndAttrsAPI.alias.prop.getter.bind(_this2)(aliasedPropName);
              },
              enumerable: true
            });
          }
        }
      },
      boolean: {
        prop: {
          setter: function setter(attrName, value) {
            if (value) {
              this.setAttribute(attrName, "");
            } else {
              this.removeAttribute(attrName);
            }
          },
          getter: function getter(attrName) {
            return this.hasAttribute(attrName) && this.getAttribute(attrName) !== "false";
          },
          define: function define(propName, attrName) {
            var _this3 = this;

            Object.defineProperty(this, propName, {
              set: function set$$1(v) {
                return propsAndAttrsAPI.boolean.prop.setter.bind(_this3)(attrName, v);
              },
              get: function get$$1() {
                return propsAndAttrsAPI.boolean.prop.getter.bind(_this3)(attrName);
              },
              enumerable: true
            });
          }
        },
        attr: {
          onChange: function onChange(oldValue, newValue, onChangeCallback) {
            // check if the value went from being there to not being there and vice-versa, and if there is an actual function to call
            if (onChangeCallback && propsAndAttrsAPI.boolean.attr.hasChanged(oldValue, newValue)) {
              onChangeCallback(this, oldValue, newValue);
            }
          },
          hasChanged: function hasChanged(oldValue, newValue) {
            var oldValueIsFalse = oldValue == null || oldValue === "false";
            var newValueIsFalse = newValue == null || newValue === "false";
            return oldValueIsFalse !== newValueIsFalse;
          }
        }
      },
      string: {
        prop: {
          setter: function setter(attrName, value) {
            if (value != null) {
              this.setAttribute(attrName, value);
            } else {
              this.removeAttribute(attrName);
            }
          },
          getter: function getter(attrName) {
            if (this.hasAttribute(attrName)) {
              return this.getAttribute(attrName);
            }
            return null;
          },
          define: function define(propName, attrName) {
            var _this4 = this;

            Object.defineProperty(this, propName, {
              set: function set$$1(v) {
                return propsAndAttrsAPI.string.prop.setter.bind(_this4)(attrName, v);
              },
              get: function get$$1() {
                return propsAndAttrsAPI.string.prop.getter.bind(_this4)(attrName);
              },
              enumerable: true
            });
          }
        }
      },
      function: {
        prop: {
          // mostly like for object
          setter: function setter(privatePropName, value, onChange) {
            var oldValue = this[privatePropName];
            this[privatePropName] = value;
            if (onChange) onChange(this, oldValue, value);
          },
          getter: function getter(privatePropName) {
            return this[privatePropName];
          },
          define: function define(propName, privatePropName, onChange) {
            var _this5 = this;

            if (!privatePropName) {
              privatePropName = "_" + propName;
            }
            this[privatePropName] = {};
            Object.defineProperty(this, propName, {
              set: function set$$1(v) {
                propsAndAttrsAPI.function.prop.setter.bind(_this5)(privatePropName, v, onChange);
              },
              get: function get$$1() {
                return propsAndAttrsAPI.function.prop.getter.bind(_this5)(privatePropName);
              },
              enumerable: true
            });
          }
        },
        attr: {
          parse: function parse(value) {
            return parseFunction(value);
          },
          onChange: function onChange(propName, attrName, oldValue, newValue) {
            this[propName] = propsAndAttrsAPI.function.attr.parse.bind(this)(newValue);
          }
        }
      },
      number: {
        prop: {
          setter: function setter(attrName, value) {
            if (value != null && !isNaN(value)) {
              this.setAttribute(attrName, value);
            } else {
              this.removeAttribute(attrName);
            }
          }
        }
      }
    };

    var PropAndAttr = function () {
      function PropAndAttr(type, attrName, propName, onChangeCallback) {
        classCallCheck(this, PropAndAttr);

        this.type = type;
        this.attrName = attrName;
        this.propName = propName;
        this.onChangeCallback = onChangeCallback;
        if (!attrName && !propName) {
          throw new Error("attribute name and property name are not defined. You need to define at least one");
        }
      }

      createClass(PropAndAttr, [{
        key: "instanceConstructorLogic",


        /**
         *
         * @param {PFElement} pfeInstance
         */
        value: function instanceConstructorLogic(pfeInstance) {
          if (this.propName) {
            this.defineProp(pfeInstance);
          }
        }

        /**
         *
         * @param {PFElement} pfeInstance
         */

      }, {
        key: "getDefineFn",
        value: function getDefineFn(pfeInstance) {
          return propsAndAttrsAPI[this.type].prop.define.bind(pfeInstance);
        }

        /**
         *  to do: redo for each prop type / class
         * @param {PFElement} pfeInstance
         */

      }, {
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          this.getDefineFn(pfeInstance)(this.propName);
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          this.onChangeCallback(pfeInstance, oldValue, newValue);
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          // to be checked
          return this.attrName && this.onChangeCallback;
        }
      }]);
      return PropAndAttr;
    }();

    var ObjectPropAndAttr = function (_PropAndAttr) {
      inherits(ObjectPropAndAttr, _PropAndAttr);

      function ObjectPropAndAttr(attrName, propName, onChangeCallback, privatePropName) {
        classCallCheck(this, ObjectPropAndAttr);

        var _this6 = possibleConstructorReturn(this, (ObjectPropAndAttr.__proto__ || Object.getPrototypeOf(ObjectPropAndAttr)).call(this, "object", attrName, propName, onChangeCallback));

        if (_this6.propName) {
          _this6.privatePropName = privatePropName || "_" + _this6.propName;
        }
        return _this6;
      }

      /**
       *
       * @param {PFElement} pfeInstance
       */


      createClass(ObjectPropAndAttr, [{
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          this.getDefineFn(pfeInstance)(this.propName, this.privatePropName, this.onChangeCallback);
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          if (this.propName) {
            propsAndAttrsAPI.object.onChange.bind(pfeInstance)(this.propName, this.attrName, oldValue, newValue);
          }
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          return !!this.attrName;
        }
      }]);
      return ObjectPropAndAttr;
    }(PropAndAttr);

    var StringPropAndAttr = function (_PropAndAttr2) {
      inherits(StringPropAndAttr, _PropAndAttr2);

      function StringPropAndAttr(attrName, propName, onChangeCallback, privatePropName) {
        classCallCheck(this, StringPropAndAttr);

        var _this7 = possibleConstructorReturn(this, (StringPropAndAttr.__proto__ || Object.getPrototypeOf(StringPropAndAttr)).call(this, "string", attrName, propName, onChangeCallback));

        if (!_this7.attrName) {
          _this7.privatePropName = privatePropName || "_" + _this7.propName;
        }
        return _this7;
      }

      /**
       *
       * @param {PFElement} pfeInstance
       */


      createClass(StringPropAndAttr, [{
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          var _this8 = this;

          if (this.attrName) {
            this.getDefineFn(pfeInstance)(this.propName, this.attrName);
          } else {
            Object.defineProperty(pfeInstance, this.propName, {
              set: function set$$1(v) {
                var oldValue = pfeInstance[_this8.privatePropName];
                pfeInstance[_this8.privatePropName] = v;
                if (_this8.onChangeCallback) {
                  _this8.onChangeCallback(pfeInstance, oldValue, v);
                }
              },
              get: function get$$1() {
                return pfeInstance[_this8.privatePropName];
              },
              enumerable: true
            });
          }
        }
      }]);
      return StringPropAndAttr;
    }(PropAndAttr);

    var AliasPropAndAttr = function (_PropAndAttr3) {
      inherits(AliasPropAndAttr, _PropAndAttr3);

      function AliasPropAndAttr(attrName, propName, aliasedPropName, aliasedAttrName) {
        classCallCheck(this, AliasPropAndAttr);

        var _this9 = possibleConstructorReturn(this, (AliasPropAndAttr.__proto__ || Object.getPrototypeOf(AliasPropAndAttr)).call(this, "alias", attrName, propName, undefined));

        _this9.aliasedPropName = aliasedPropName;
        _this9.aliasedAttrName = aliasedAttrName;
        if (!aliasedAttrName && !aliasedAttrName) {
          throw new Error("Aliased property has no aliasedPropName and aliasedAttrName");
        }
        return _this9;
      }

      /**
       *
       * @param {PFElement} pfeInstance
       */


      createClass(AliasPropAndAttr, [{
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          var _this10 = this;

          if (this.aliasedPropName) {
            this.getDefineFn(pfeInstance)(this.propName, this.aliasedPropName);
          } else if (this.aliasedAttrName) {
            Object.defineProperty(pfeInstance, this.propName, {
              set: function set$$1(v) {
                pfeInstance.setAttribute(_this10.aliasedAttrName, v);
              },
              get: function get$$1() {
                return pfeInstance.hasAttribute(_this10.aliasedAttrName) && pfeInstance.getAttribute(_this10.aliasedAttrName);
              },
              enumerable: true
            });
          }
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          if (this.aliasedAttrName) {
            pfeInstance.setAttribute(this.aliasedAttrName, newValue);
          } else if (this.aliasedPropName) {
            pfeInstance[this.aliasedPropName] = newValue;
          }
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          return !!this.attrName;
        }
      }]);
      return AliasPropAndAttr;
    }(PropAndAttr);

    var BooleanPropAndAttr = function (_PropAndAttr4) {
      inherits(BooleanPropAndAttr, _PropAndAttr4);

      function BooleanPropAndAttr(attrName, propName, onChangeCallback, privatePropName) {
        classCallCheck(this, BooleanPropAndAttr);

        var _this11 = possibleConstructorReturn(this, (BooleanPropAndAttr.__proto__ || Object.getPrototypeOf(BooleanPropAndAttr)).call(this, "boolean", attrName, propName, onChangeCallback));

        if (!attrName) {
          _this11.privatePropName = privatePropName || "_" + propName;
        }
        return _this11;
      }

      createClass(BooleanPropAndAttr, [{
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          var _this12 = this;

          if (this.attrName) {
            this.getDefineFn(pfeInstance)(this.propName, this.attrName);
          } else {
            Object.defineProperty(pfeInstance, this.propName, {
              set: function set$$1(v) {
                var oldValue = pfeInstance[_this12.privatePropName];
                pfeInstance[_this12.privatePropName] = !!v;
                if (_this12.onChangeCallback) {
                  _this12.onChangeCallback(pfeInstance, oldValue, v);
                }
              },
              get: function get$$1() {
                return pfeInstance[_this12.privatePropName];
              },
              enumerable: true
            });
          }
        }
      }]);
      return BooleanPropAndAttr;
    }(PropAndAttr);

    var FunctionPropAndAttr = function (_PropAndAttr5) {
      inherits(FunctionPropAndAttr, _PropAndAttr5);

      function FunctionPropAndAttr(attrName, propName, onChangeCallback, privatePropName) {
        classCallCheck(this, FunctionPropAndAttr);

        var _this13 = possibleConstructorReturn(this, (FunctionPropAndAttr.__proto__ || Object.getPrototypeOf(FunctionPropAndAttr)).call(this, "function", attrName, propName, onChangeCallback));

        if (!propName || typeof propName !== "string") {
          throw new Error("propName must be a non-empty string for functions");
        }
        _this13.privatePropName = privatePropName || "_" + propName;
        return _this13;
      }

      createClass(FunctionPropAndAttr, [{
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          this.getDefineFn(pfeInstance)(this.propName, this.privatePropName, this.onChangeCallback);
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          propsAndAttrsAPI.object.onChange.bind(pfeInstance)(this.propName, this.attrName, oldValue, newValue);
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          return !!this.attrName;
        }
      }]);
      return FunctionPropAndAttr;
    }(PropAndAttr);

    var NumberPropAndAttr = function (_PropAndAttr6) {
      inherits(NumberPropAndAttr, _PropAndAttr6);

      function NumberPropAndAttr(type, attrName, propName, onChangeCallback, privatePropName) {
        classCallCheck(this, NumberPropAndAttr);

        var _this14 = possibleConstructorReturn(this, (NumberPropAndAttr.__proto__ || Object.getPrototypeOf(NumberPropAndAttr)).call(this, type, attrName, propName, onChangeCallback));

        if (!attrName || privatePropName) {
          _this14.privatePropName = privatePropName || "_" + propName;
        }
        return _this14;
      }

      createClass(NumberPropAndAttr, [{
        key: "parse",
        value: function parse(value) {
          return Number(value);
        }
      }, {
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          var _this15 = this;

          if (this.privatePropName && this.attrName) {
            throw new Error("Not implemented yet for " + this.type + " prop and attribute");
          } else if (this.attrName) {
            Object.defineProperty(pfeInstance, this.propName, {
              set: function set$$1(v) {
                propsAndAttrsAPI.number.prop.setter.bind(pfeInstance)(_this15.attrName, v);
              },
              get: function get$$1() {
                if (pfeInstance.hasAttribute(_this15.attrName)) {
                  return _this15.parse(pfeInstance.getAttribute(_this15.attrName));
                }
              },
              enumerable: true
            });
          } else {
            Object.defineProperty(pfeInstance, this.propName, {
              set: function set$$1(v) {
                var oldValue = pfeInstance[_this15.privatePropName];
                pfeInstance[_this15.privatePropName] = v;
              },
              get: function get$$1() {
                return pfeInstance[_this15.privatePropName];
              },
              enumerable: true
            });
          }
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          if (this.privatePropName && this.attrName) {
            throw new Error("Not implemented yet for " + this.type + " prop and attribute");
          } else {
            var oldNum = this.parse(oldValue);
            var newNum = this.parse(newValue);
            this.onChangeCallback(pfeInstance, oldNum, newNum);
          }
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          return get(NumberPropAndAttr.prototype.__proto__ || Object.getPrototypeOf(NumberPropAndAttr.prototype), "attrIsObserved", this) || this.privatePropName && this.attrName;
        }
      }]);
      return NumberPropAndAttr;
    }(PropAndAttr);

    var IntPropAndAttr = function (_NumberPropAndAttr) {
      inherits(IntPropAndAttr, _NumberPropAndAttr);

      function IntPropAndAttr(attrName, propName, onChangeCallback) {
        classCallCheck(this, IntPropAndAttr);
        return possibleConstructorReturn(this, (IntPropAndAttr.__proto__ || Object.getPrototypeOf(IntPropAndAttr)).call(this, "integer", attrName, propName, onChangeCallback));
      }

      createClass(IntPropAndAttr, [{
        key: "parse",
        value: function parse(value) {
          return parseInt(value);
        }
      }]);
      return IntPropAndAttr;
    }(NumberPropAndAttr);

    var FloatPropAndAttr = function (_NumberPropAndAttr2) {
      inherits(FloatPropAndAttr, _NumberPropAndAttr2);

      function FloatPropAndAttr(attrName, propName, onChangeCallback) {
        classCallCheck(this, FloatPropAndAttr);
        return possibleConstructorReturn(this, (FloatPropAndAttr.__proto__ || Object.getPrototypeOf(FloatPropAndAttr)).call(this, "float", attrName, propName, onChangeCallback));
      }

      createClass(FloatPropAndAttr, [{
        key: "parse",
        value: function parse(value) {
          return parseFloat(value);
        }
      }]);
      return FloatPropAndAttr;
    }(NumberPropAndAttr);

    var errorWrapperElementNotDefined = new Error("The wrapped element is not yet obtainable. The property must be set in a different way, or after the wrapped element is obtainable");

    var WrappedPropAndAttr = function (_PropAndAttr7) {
      inherits(WrappedPropAndAttr, _PropAndAttr7);

      function WrappedPropAndAttr(attrName, propName, onChangeCallback, getWrappedElementFn, wrappedAttrName, wrappedPropName) {
        classCallCheck(this, WrappedPropAndAttr);

        var _this18 = possibleConstructorReturn(this, (WrappedPropAndAttr.__proto__ || Object.getPrototypeOf(WrappedPropAndAttr)).call(this, "wrapped", attrName, propName, onChangeCallback));

        if (typeof getWrappedElementFn !== "function") {
          throw new Error("getWrappedElementFn must be a function that returns an html element for wrapped prop and attr type");
        }
        if (!wrappedAttrName && !wrappedPropName) {
          throw new Error("one of wrappedAttrName and wrappedPropName must be defined, for wrapped prop and attr type");
        }
        _this18.getWrappedElementFn = getWrappedElementFn;
        _this18.wrappedAttrName = wrappedAttrName;
        _this18.wrappedPropName = wrappedPropName;
        return _this18;
      }

      createClass(WrappedPropAndAttr, [{
        key: "updateAttrFromWrappedAttribute",
        value: function updateAttrFromWrappedAttribute(pfeInstance) {
          var wrappedEl = this.getWrappedElementFn(pfeInstance);
          if (wrappedEl) {
            if (wrappedEl.hasAttribute(this.wrappedAttrName)) {
              pfeInstance.setAttribute(this.attrName, wrappedEl.getAttribute(this.wrappedAttrName));
            } else {
              pfeInstance.removeAttribute(this.attrName);
            }
          } else {
            throw errorWrapperElementNotDefined;
          }
        }
      }, {
        key: "updateWrappedAttribute",
        value: function updateWrappedAttribute(pfeInstance, value) {
          var wrappedEl = this.getWrappedElementFn(pfeInstance);
          if (wrappedEl) {
            if (value != null) {
              wrappedEl.setAttribute(this.wrappedAttrName, value);
            } else {
              wrappedEl.removeAttribute(this.wrappedAttrName);
            }
          } else {
            throw errorWrapperElementNotDefined;
          }
        }
      }, {
        key: "defineProp",
        value: function defineProp(pfeInstance) {
          var _this19 = this;

          var attributes = { enumerable: true };

          if (this.wrappedPropName) {
            attributes.set = function (v) {
              var wrappedEl = _this19.getWrappedElementFn(pfeInstance);
              if (wrappedEl) {
                var oldValue = pfeInstance[_this19.propName];
                wrappedEl[_this19.wrappedPropName] = v;
                if (_this19.wrappedAttrName && _this19.attrName) {
                  _this19.updateAttrFromWrappedAttribute(pfeInstance);
                } else if (_this19.onChangeCallback) {
                  _this19.onChangeCallback(pfeInstance, oldValue, pfeInstance[_this19.propName]);
                }
              } else {
                // this could be implemented in the future
                throw errorWrapperElementNotDefined;
              }
              // to do! add onchange somewhere
            };
            attributes.get = function () {
              var wrappedEl = _this19.getWrappedElementFn(pfeInstance);
              if (wrappedEl) {
                return wrappedEl[_this19.wrappedPropName];
              } else {
                throw errorWrapperElementNotDefined;
              }
            };
          } else {
            // wrappedAttrName

            attributes.set = function (v) {
              var wrappedEl = _this19.getWrappedElementFn(pfeInstance);
              if (wrappedEl) {
                var oldValue = pfeInstance[_this19.propName];
                _this19.updateWrappedAttribute(pfeInstance, v);
                if (_this19.attrName) {
                  _this19.updateAttrFromWrappedAttribute(pfeInstance);
                } else if (_this19.onChangeCallback) {
                  _this19.onChangeCallback(pfeInstance, oldValue, pfeInstance[_this19.propName]);
                }
              } else {
                throw errorWrapperElementNotDefined;
              }
            };
            attributes.get = function () {
              var wrappedEl = _this19.getWrappedElementFn(pfeInstance);
              if (wrappedEl) {
                if (wrappedEl.hasAttribute(_this19.wrappedAttrName)) {
                  return wrappedEl.getAttribute(_this19.wrappedAttrName);
                }
              } else {
                throw errorWrapperElementNotDefined;
              }
            };
          }

          Object.defineProperty(pfeInstance, this.propName, attributes);
        }
      }, {
        key: "onAttributeChangedLogic",
        value: function onAttributeChangedLogic(pfeInstance, oldValue, newValue) {
          var wrapperEl = this.getWrappedElementFn(pfeInstance);
          if (wrapperEl) {
            if (oldValue !== newValue) {
              if (this.wrappedAttrName) {
                this.updateWrappedAttribute(pfeInstance, newValue);
                this.updateAttrFromWrappedAttribute(pfeInstance);
              } else if (this.propName) {
                pfeInstance[this.propName] = newValue;
              }
              if (this.onChangeCallback) {
                this.onChangeCallback(pfeInstance, oldValue, newValue);
              }
            }
          } else {
            throw errorWrapperElementNotDefined;
          }
        }
      }, {
        key: "attrIsObserved",
        get: function get$$1() {
          return !!this.attrName;
        }
      }]);
      return WrappedPropAndAttr;
    }(PropAndAttr);

    /*!
     * PatternFly Elements: PFElement 2.1.0-alpha.1
     * @license
     * Copyright 2020 Red Hat, Inc.
     * 
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     * 
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     * 
    */
    var prefix = "pfe-";

    var PFElement = function (_HTMLElement) {
      inherits(PFElement, _HTMLElement);
      createClass(PFElement, [{
        key: "propsAndAttrsConstructorLogic",
        value: function propsAndAttrsConstructorLogic() {
          var _this2 = this;

          this._pfeClass.propsAndAttrs.forEach(function (propAndAttrInstance) {
            return propAndAttrInstance.instanceConstructorLogic(_this2);
          });
        }
      }, {
        key: "propsAndAttrsOnAttributeChangedLogic",
        value: function propsAndAttrsOnAttributeChangedLogic(attrName, oldValue, newValue) {
          var foundElements = this._pfeClass.propsAndAttrs.filter(function (propAndAttrInstance) {
            return propAndAttrInstance.attrName === attrName;
          });
          if (foundElements.length) {
            if (foundElements.length > 1) {
              throw new Error("more than one attribute with the same name has been defined in propAndAttr api");
            }
            foundElements[0].onAttributeChangedLogic(this, oldValue, newValue);
          }
        }
      }, {
        key: "cssVariable",
        value: function cssVariable(name, value) {
          var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

          name = name.substr(0, 2) !== "--" ? "--" + name : name;
          if (value) {
            element.style.setProperty(name, value);
          }
          return window.getComputedStyle(element).getPropertyValue(name).trim();
        }

        // Returns a single element assigned to that slot; if multiple, it returns the first

      }, {
        key: "has_slot",
        value: function has_slot(name) {
          return this.querySelector("[slot='" + name + "']");
        }

        // Returns an array with all elements assigned to that slot

      }, {
        key: "has_slots",
        value: function has_slots(name) {
          return [].concat(toConsumableArray(this.querySelectorAll("[slot='" + name + "']")));
        }

        // Update the theme context for self and children

      }, {
        key: "context_update",
        value: function context_update() {
          var children = this.querySelectorAll("[pfelement]");
          var theme = this.cssVariable("theme");

          // Manually adding `pfe-theme` overrides the css variable
          if (this.hasAttribute("pfe-theme")) {
            theme = this.getAttribute("pfe-theme");
            // Update the css variable to match the data attribute
            this.cssVariable("theme", theme);
          }

          // Update theme for self
          this.context_set(theme);

          // For each nested, already upgraded component
          // set the context based on the child's value of --theme
          // Note: this prevents contexts from parents overriding
          // the child's context should it exist
          [].concat(toConsumableArray(children)).map(function (child) {
            if (child.connected) {
              child.context_set(theme);
            }
          });
        }

        // Get the theme variable if it exists, set it as an attribute

      }, {
        key: "context_set",
        value: function context_set(fallback) {
          var theme = this.cssVariable("theme");
          if (!theme) {
            theme = this.getAttribute("pfe-theme");
          }
          if (!theme && fallback) {
            theme = fallback;
          }
          if (theme) {
            this.setAttribute("on", theme);
          }
        }
      }, {
        key: "randomId",
        get: function get$$1() {
          return Math.random().toString(36).substr(2, 9);
        }
      }, {
        key: "version",
        get: function get$$1() {
          return this._pfeClass.version;
        }
      }, {
        key: "pfeType",
        get: function get$$1() {
          return this.getAttribute(prefix + "type");
        },
        set: function set$$1(value) {
          this.setAttribute(prefix + "type", value);
        }
      }], [{
        key: "create",
        value: function create(pfe) {
          window.customElements.define(pfe.tag, pfe);
        }

        /**
         *
         * @returns {PropAndAttr[]}
         */

      }, {
        key: "debugLog",
        value: function debugLog() {
          var preference = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (preference !== null) {
            PFElement._debugLog = !!preference;
          }
          return PFElement._debugLog;
        }
      }, {
        key: "log",
        value: function log() {
          if (PFElement.debugLog()) {
            var _console;

            (_console = console).log.apply(_console, arguments);
          }
        }
      }, {
        key: "propsAndAttrs",
        get: function get$$1() {
          return [];
        }
      }, {
        key: "propsAndAttrsAPI",
        get: function get$$1() {
          return {
            alias: AliasPropAndAttr,
            boolean: BooleanPropAndAttr,
            float: FloatPropAndAttr,
            function: FunctionPropAndAttr,
            integer: IntPropAndAttr,
            number: NumberPropAndAttr,
            object: ObjectPropAndAttr,
            string: StringPropAndAttr,
            wrapped: WrappedPropAndAttr
          };
        }
      }, {
        key: "propAndAttrsObservedAttributes",
        get: function get$$1() {
          return this.propsAndAttrs.filter(function (propAndAttrInstance) {
            return propAndAttrInstance.attrIsObserved;
          }).map(function (propAndAttrInstance) {
            return propAndAttrInstance.attrName;
          });
        }
      }, {
        key: "PfeTypes",
        get: function get$$1() {
          return {
            Container: "container",
            Content: "content",
            Combo: "combo"
          };
        }
      }, {
        key: "version",
        get: function get$$1() {
          return "{{version}}";
        }
      }, {
        key: "observedAttributes",
        get: function get$$1() {
          return ["pfe-theme"].concat(toConsumableArray(this.propAndAttrsObservedAttributes));
        }
      }]);

      function PFElement(pfeClass) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$type = _ref.type,
            type = _ref$type === undefined ? null : _ref$type,
            _ref$delayRender = _ref.delayRender,
            delayRender = _ref$delayRender === undefined ? false : _ref$delayRender,
            _ref$customRendering = _ref.customRendering,
            customRendering = _ref$customRendering === undefined ? false : _ref$customRendering;

        classCallCheck(this, PFElement);

        var _this = possibleConstructorReturn(this, (PFElement.__proto__ || Object.getPrototypeOf(PFElement)).call(this));

        _this.connected = false;
        _this._pfeClass = pfeClass;
        _this.tag = pfeClass.tag;
        _this.props = pfeClass.properties;
        _this.slots = pfeClass.slots;
        _this._queue = [];

        if (type) {
          _this._queueAction({
            type: "setProperty",
            data: {
              name: "pfeType",
              value: type
            }
          });
        }

        _this._connectedCallback = _this._connectedCallback.bind(_this);
        _this._observer = new MutationObserver(_this._connectedCallback); // not used yet, just created

        if (!customRendering) {
          _this.template = document.createElement("template");

          _this.log("Constructing...");

          if (_this.tag !== "pfe-table") {
            _this.attachShadow({ mode: "open" });
          }

          if (!delayRender && (_this.tag !== "pfe-navigation" || _this.tag !== "pfe-navigation-main" || _this.tag !== "pfe-navigation-item" || _this.tag !== "pfe-card")) {
            if (!delayRender) {
              _this.log("Render...");
              _this.render();
              _this.log("Rendered.");
            }
          } else {
            if (_this.tag !== "pfe-table") {
              _this.shadowRoot.innerHTML = "<slot></slot>";
            }
          }
        }

        _this.propsAndAttrsConstructorLogic();
        return _this;
      }

      createClass(PFElement, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          var _this3 = this;

          if (this.tag === "pfe-navigation" || this.tag === "pfe-navigation-main" || this.tag === "pfe-navigation-item" || this.tag === "pfe-card") {
            return new Promise(function (resolve) {
              setTimeout(function () {
                if (_this3.children.length) {
                  _this3.render();
                  _this3._connectedCallback();
                  return resolve();
                }

                _this3._observer.observe(_this3, { childList: true });
              }, 0);
            });
          } else {
            this._connectedCallback();
          }
        }
      }, {
        key: "_connectedCallback",
        value: function _connectedCallback() {
          this.connected = true;
          this.log("Connecting...");

          if (this.tag !== "pfe-table" && window.ShadyCSS) {
            this.log("Styling...");
            window.ShadyCSS.styleElement(this);
            // this.temporaryFixIE11EdgeSlotted();
            this.log("Styled.");
          }

          // Throw a warning if the on attribute was manually added before upgrade
          if (!this.hasAttribute("pfelement") && this.hasAttribute("on")) {
            console.warn("" + this.tag + (this.id ? "[#" + this.id + "]" : "") + ": The \"on\" attribute is protected and should not be manually added to a component. The base class will manage this value for you on upgrade.");
          }

          // @TODO maybe we should use just the attribute instead of the class?
          // https://github.com/angular/angular/issues/15399#issuecomment-318785677
          this.classList.add("PFElement");
          this.setAttribute("pfelement", "");

          if (_typeof(this.props) === "object") {
            this._mapSchemaToProperties(this.tag, this.props);
            this.log("Properties attached.");
          }

          if (_typeof(this.slots) === "object") {
            this._mapSchemaToSlots(this.tag, this.slots);
            this.log("Slots attached.");
          }

          if (this._queue.length) {
            this._processQueue();
          }

          // Initialize the on attribute if a theme variable is set
          // do not update the on attribute if a user has manually added it
          // then trigger an update in nested components
          this.context_update();

          this.log("Connected.");
        }
      }, {
        key: "temporaryFixIE11EdgeSlotted",
        value: function temporaryFixIE11EdgeSlotted() {
          // ENABLE THIS PATCH WHEN SLOT ARE NOT SUPPORTED
          var tagName = "" + this.tag;
          var getStyleTag = document.head.querySelector("[scope^=" + tagName + "]");

          if (getStyleTag) {
            var style = Array.from(document.styleSheets).find(function (item) {
              if (item.ownerNode && item.ownerNode.getAttribute("scope").indexOf(tagName) !== -1) {
                return item;
              }
              return null;
            });
            if (style) {
              var dynamicSlot = "";
              Array.from(style.cssRules || style.rules || []).forEach(function (rule) {
                if (rule.selectorText && typeof rule.cssText === "string" && rule.selectorText.indexOf("slot") > -1) {
                  dynamicSlot += " " + rule.cssText.replace(/>/gi, "");
                } else if (rule && typeof rule.cssText === "string") {
                  dynamicSlot += " " + rule.cssText;
                }
              });
              if (dynamicSlot) {
                getStyleTag.innerText = dynamicSlot;
              }
            }
          }
        }
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          this._observer.disconnect();
          this.log("Disconnecting...");

          this.connected = false;

          this.log("Disconnected.");
        }
      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(attr, oldVal, newVal) {
          if (this._pfeClass.cascadingAttributes) {
            var cascadeTo = this._pfeClass.cascadingAttributes[attr];
            if (cascadeTo) {
              this._copyAttribute(attr, cascadeTo);
            }

            if (attr === "pfe-theme") {
              this.context_update();
            }
          }

          this.propsAndAttrsOnAttributeChangedLogic(attr, oldVal, newVal);
        }
      }, {
        key: "_copyAttribute",
        value: function _copyAttribute(name, to) {
          var recipients = [].concat(toConsumableArray(this.querySelectorAll(to)), toConsumableArray(this.shadowRoot.querySelectorAll(to)));
          var value = this.getAttribute(name);
          var fname = value == null ? "removeAttribute" : "setAttribute";
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = recipients[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var node = _step.value;

              node[fname](name, value);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        // Map the imported properties json to real props on the element
        // @notice static getter of properties is built via tooling
        // to edit modify src/element.json

      }, {
        key: "_mapSchemaToProperties",
        value: function _mapSchemaToProperties(tag, properties) {
          var _this4 = this;

          this.log("Mapping properties...");
          // Loop over the properties provided by the schema
          Object.keys(properties).forEach(function (attr) {
            var data = properties[attr];

            // Only attach the information if the data provided is a schema object
            if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
              // Prefix default is true
              var hasPrefix = true;
              var attrName = attr;
              // Set the attribute's property equal to the schema input
              _this4[attr] = data;
              // Initialize the value to null
              _this4[attr].value = null;

              if (typeof _this4[attr].prefixed !== "undefined") {
                hasPrefix = _this4[attr].prefixed;
              }

              if (hasPrefix) {
                attrName = "" + prefix + attr;
              }

              // If the attribute exists on the host
              if (_this4.hasAttribute(attrName)) {
                // Set property value based on the existing attribute
                _this4[attr].value = _this4.getAttribute(attrName);
              }
              // Otherwise, look for a default and use that instead
              else if (data.default) {
                  var dependency_exists = _this4._hasDependency(tag, data.options);
                  var no_dependencies = !data.options || data.options && !data.options.dependencies.length;
                  // If the dependency exists or there are no dependencies, set the default
                  if (dependency_exists || no_dependencies) {
                    _this4.setAttribute(attrName, data.default);
                    _this4[attr].value = data.default;
                  }
                }
            }
          });

          this.log("Properties mapped.");
        }

        // Test whether expected dependencies exist

      }, {
        key: "_hasDependency",
        value: function _hasDependency(tag, opts) {
          // Get any possible dependencies for this attribute to exist
          var dependencies = opts ? opts.dependencies : [];
          // Initialize the dependency return value
          var hasDependency = false;
          // Check that dependent item exists
          // Loop through the dependencies defined
          for (var i = 0; i < dependencies.length; i += 1) {
            var slot_exists = dependencies[i].type === "slot" && this.has_slots(tag + "--" + dependencies[i].id).length > 0;
            var attribute_exists = dependencies[i].type === "attribute" && this.getAttribute("" + prefix + dependencies[i].id);
            // If the type is slot, check that it exists OR
            // if the type is an attribute, check if the attribute is defined
            if (slot_exists || attribute_exists) {
              // If the slot does exist, add the attribute with the default value
              hasDependency = true;
              // Exit the loop
              break;
            }
          }
          // Return a boolean if the dependency exists
          return hasDependency;
        }

        // Map the imported slots json
        // @notice static getter of properties is built via tooling
        // to edit modify src/element.json

      }, {
        key: "_mapSchemaToSlots",
        value: function _mapSchemaToSlots(tag, slots) {
          var _this5 = this;

          this.log("Validate slots...");
          // Loop over the properties provided by the schema
          Object.keys(slots).forEach(function (slot) {
            var slotObj = slots[slot];

            // Only attach the information if the data provided is a schema object
            if ((typeof slotObj === "undefined" ? "undefined" : _typeof(slotObj)) === "object") {
              var slotExists = false;
              var result = [];
              // If it's a named slot, look for that slot definition
              if (slotObj.namedSlot) {
                // Check prefixed slots
                result = _this5.has_slots(tag + "--" + slot);
                if (result.length > 0) {
                  slotObj.nodes = result;
                  slotExists = true;
                }

                // Check for unprefixed slots
                result = _this5.has_slots("" + slot);
                if (result.length > 0) {
                  slotObj.nodes = result;
                  slotExists = true;
                }
                // If it's the default slot, look for direct children not assigned to a slot
              } else {
                result = [].concat(toConsumableArray(_this5.children)).filter(function (child) {
                  return !child.hasAttribute("slot");
                });

                if (result.length > 0) {
                  slotObj.nodes = result;
                  slotExists = true;
                }
              }

              // If the slot exists, attach an attribute to the parent to indicate that
              if (slotExists) {
                _this5.setAttribute("has_" + slot, "");
              } else {
                _this5.removeAttribute("has_" + slot);
              }
            }
          });
          this.log("Slots validated.");
        }
      }, {
        key: "_queueAction",
        value: function _queueAction(action) {
          this._queue.push(action);
        }
      }, {
        key: "_processQueue",
        value: function _processQueue() {
          var _this6 = this;

          this._queue.forEach(function (action) {
            _this6["_" + action.type](action.data);
          });

          this._queue = [];
        }
      }, {
        key: "_setProperty",
        value: function _setProperty(_ref2) {
          var name = _ref2.name,
              value = _ref2.value;

          this[name] = value;
        }

        // @TODO This is a duplicate function to cssVariable above, combine them

      }, {
        key: "var",
        value: function _var(name) {
          return PFElement.var(name, this);
        }
      }, {
        key: "render",
        value: function render() {
          this.shadowRoot.innerHTML = "";
          this.template.innerHTML = this.html;

          if (window.ShadyCSS) {
            window.ShadyCSS.prepareTemplate(this.template, this.tag);
          }

          this.shadowRoot.appendChild(this.template.content.cloneNode(true));
        }
      }, {
        key: "log",
        value: function log() {
          for (var _len = arguments.length, msgs = Array(_len), _key = 0; _key < _len; _key++) {
            msgs[_key] = arguments[_key];
          }

          PFElement.log.apply(PFElement, ["[" + this.tag + "]"].concat(msgs));
        }
      }, {
        key: "emitEvent",
        value: function emitEvent(name) {
          var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref3$bubbles = _ref3.bubbles,
              bubbles = _ref3$bubbles === undefined ? true : _ref3$bubbles,
              _ref3$cancelable = _ref3.cancelable,
              cancelable = _ref3$cancelable === undefined ? false : _ref3$cancelable,
              _ref3$composed = _ref3.composed,
              composed = _ref3$composed === undefined ? false : _ref3$composed,
              _ref3$detail = _ref3.detail,
              detail = _ref3$detail === undefined ? {} : _ref3$detail;

          this.log("Custom event: " + name);
          this.dispatchEvent(new CustomEvent(name, {
            bubbles: bubbles,
            cancelable: cancelable,
            composed: composed,
            detail: detail
          }));
        }
      }, {
        key: "getUniqueId",
        value: function getUniqueId() {
          var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "id";

          var id = prefix;
          for (var i = 1; document.getElementById(id); i++) {
            id = prefix + "-" + i;
          }
          return id;
        }
      }], [{
        key: "var",
        value: function _var(name) {
          var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;

          return window.getComputedStyle(element).getPropertyValue(name).trim();
        }
      }]);
      return PFElement;
    }(HTMLElement);

    autoReveal(PFElement.log);

    return PFElement;

})));
//# sourceMappingURL=pfelement.umd.js.map
